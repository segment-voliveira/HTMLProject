"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeShouldLoadSegment = exports.LoadContext = exports.LoadToken = exports.AbortLoadError = void 0;
const errors_1 = require("../types/errors");
const logger_1 = require("./logger");
const validation_error_1 = require("./validation/validation-error");
/**
 * Thrown when a load should be cancelled.
 */
class AbortLoadError extends errors_1.AnalyticsConsentError {
    constructor(loadSegmentNormally) {
        super('AbortLoadError', '');
        this.loadSegmentNormally = loadSegmentNormally;
    }
}
exports.AbortLoadError = AbortLoadError;
class LoadToken {
    constructor(options) {
        this.options = options;
    }
}
exports.LoadToken = LoadToken;
class LoadContext {
    constructor() {
        this.isAbortCalled = false;
        this.isLoadCalled = false;
        this.abortLoadOptions = {
            loadSegmentNormally: true,
        };
        this.loadOptions = {
            /**
             * Opt-in consent
             */
            consentModel: 'opt-in',
        };
    }
    /**
     * Allow analytics.js to be initialized with the consent wrapper.
     * Note: load just means 'allowed to load' -- we still wait for analytics.load to be explicitly called.
     */
    load(options) {
        this.isLoadCalled = true;
        this.loadOptions = { ...this.loadOptions, ...options };
        logger_1.logger.debug('ctx.load called', this.loadOptions);
    }
    /**
     * Abort the _consent-wrapped_ analytics.js initialization
     */
    abort(options) {
        this.isAbortCalled = true;
        this.abortLoadOptions = { ...this.abortLoadOptions, ...options };
        logger_1.logger.debug('Abort consent wrapper', this.loadOptions);
    }
    validate() {
        if (this.isAbortCalled && this.isLoadCalled) {
            throw new validation_error_1.ValidationError('both abort and load should not be called');
        }
    }
}
exports.LoadContext = LoadContext;
/**
 * Wrapper for shouldLoadSegment fn
 */
const normalizeShouldLoadSegment = (shouldLoadSegment) => {
    return async () => {
        const loadCtx = new LoadContext();
        await shouldLoadSegment?.(loadCtx);
        loadCtx.validate();
        return loadCtx;
    };
};
exports.normalizeShouldLoadSegment = normalizeShouldLoadSegment;
//# sourceMappingURL=load-context.js.map