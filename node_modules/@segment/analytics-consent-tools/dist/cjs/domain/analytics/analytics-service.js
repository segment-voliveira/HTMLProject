"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInitializedAnalytics = exports.AnalyticsService = void 0;
const analytics_generic_utils_1 = require("@segment/analytics-generic-utils");
const utils_1 = require("../../utils");
const blocking_middleware_1 = require("../blocking-middleware");
const consent_stamping_1 = require("../consent-stamping");
const pruned_categories_1 = require("../pruned-categories");
const validation_1 = require("../validation");
const logger_1 = require("../logger");
const config_helpers_1 = require("../config-helpers");
const blocking_helpers_1 = require("../blocking-helpers");
/**
 * This class is a wrapper around the analytics.js library.
 */
class AnalyticsService {
    get analytics() {
        return (0, exports.getInitializedAnalytics)(this.uninitializedAnalytics);
    }
    get cdnSettings() {
        return this.cdnSettingsDeferred.promise;
    }
    async getAllCategories() {
        const allCategories = this.settings.integrationCategoryMappings
            ? (0, config_helpers_1.parseAllCategories)(this.settings.integrationCategoryMappings)
            : (await this.cdnSettings).consentSettings?.allCategories;
        return allCategories ?? [];
    }
    async getCategories() {
        const categories = await this.settings.getCategories();
        (0, validation_1.validateCategories)(categories);
        return categories;
    }
    constructor(analytics, options) {
        this.cdnSettingsDeferred = (0, analytics_generic_utils_1.createDeferred)();
        /**
         * Allow for gracefully passing a custom disable function (without clobbering the default behavior)
         */
        this.createDisableOption = (categories, disable) => {
            if (disable === true) {
                return true;
            }
            return (cdnSettings) => {
                return ((0, blocking_helpers_1.segmentShouldBeDisabled)(categories, cdnSettings.consentSettings) ||
                    (typeof disable === 'function' ? disable(cdnSettings) : false));
            };
        };
        (0, validation_1.validateAnalyticsInstance)(analytics);
        this.settings = options;
        this.uninitializedAnalytics = analytics;
        this.ogAnalyticsLoad = analytics.load.bind(analytics);
    }
    async loadWithFilteredDeviceModeDestinations(...[settings, options]) {
        const initialCategories = await this.getCategories();
        const _filterDeviceModeDestinationsForOptIn = (cdnSettings) => (0, blocking_helpers_1.filterDeviceModeDestinationsForOptIn)(cdnSettings, initialCategories, {
            shouldEnableIntegration: this.settings.shouldEnableIntegration,
            integrationCategoryMappings: this.settings.integrationCategoryMappings,
        });
        return this.load(settings, {
            ...options,
            updateCDNSettings: (0, utils_1.pipe)(_filterDeviceModeDestinationsForOptIn, options?.updateCDNSettings ?? ((id) => id)),
            disable: this.createDisableOption(initialCategories, options?.disable),
        });
    }
    /**
     * The orignal analytics load function, but also stores the CDN settings on the instance.
     */
    load(...[settings, options]) {
        return this.ogAnalyticsLoad(settings, {
            ...options,
            updateCDNSettings: (0, utils_1.pipe)(options?.updateCDNSettings || ((id) => id), (cdnSettings) => {
                logger_1.logger.debug('CDN settings loaded', cdnSettings);
                // extract the CDN settings from this call and store it on the instance.
                this.cdnSettingsDeferred.resolve(cdnSettings);
                return cdnSettings;
            }),
        });
    }
    /**
     * Replace the load fn with a new one
     */
    replaceLoadMethod(loadFn) {
        this.analytics.load = loadFn;
    }
    page() {
        this.analytics.page();
    }
    configureBlockingMiddlewareForOptOut() {
        (0, blocking_middleware_1.addBlockingMiddleware)(this.cdnSettings, this.analytics, {
            integrationCategoryMappings: this.settings.integrationCategoryMappings,
            shouldEnableIntegration: this.settings.shouldEnableIntegration,
        });
    }
    configureConsentStampingMiddleware() {
        const { pruneUnmappedCategories } = this.settings;
        // normalize getCategories pruning is turned on or off
        const getCategoriesForConsentStamping = async () => {
            const categories = await this.getCategories();
            if (pruneUnmappedCategories) {
                return (0, pruned_categories_1.getPrunedCategories)(categories, await this.getAllCategories());
            }
            return categories;
        };
        const MW = (0, consent_stamping_1.createConsentStampingMiddleware)(getCategoriesForConsentStamping);
        this.analytics.addSourceMiddleware(MW);
    }
    /**
     * Dispatch an event that looks like:
     * ```ts
     * {
     * "type": "track",
     *  "event": "Segment Consent Preference Updated",
     *  "context": {
     *    "consent": {
     *      "categoryPreferences" : {
     *         "C0001": true,
     *         "C0002": false,
     *    }
     *  }
     * ...
     * ```
     */
    consentChange(categories) {
        logger_1.logger.debug('Consent change', categories);
        try {
            (0, validation_1.validateCategories)(categories);
        }
        catch (e) {
            // not sure if there's a better way to handle this
            return console.error(e);
        }
        const CONSENT_CHANGED_EVENT = 'Segment Consent Preference Updated';
        this.analytics.track(CONSENT_CHANGED_EVENT, undefined, {
            consent: { categoryPreferences: categories },
        });
    }
}
exports.AnalyticsService = AnalyticsService;
/**
 * Get possibly-initialized analytics.
 *
 * Reason:
 * There is a known bug for people who attempt to to wrap the library: the analytics reference does not get updated when the analytics.js library loads.
 * Thus, we need to proxy events to the global reference instead.
 *
 * There is a universal fix here: however, many users may not have updated it:
 * https://github.com/segmentio/snippet/commit/081faba8abab0b2c3ec840b685c4ff6d6cccf79c
 */
const getInitializedAnalytics = (analytics) => {
    const isSnippetUser = Array.isArray(analytics);
    if (isSnippetUser) {
        const opts = analytics._loadOptions ?? {};
        const globalAnalytics = window[opts?.globalAnalyticsKey ?? 'analytics'];
        // we could probably skip this check and always return globalAnalytics, since they _should_ be set to the same thing at this point
        // however, it is safer to keep buffering.
        if (globalAnalytics?.initialized) {
            return globalAnalytics;
        }
    }
    return analytics;
};
exports.getInitializedAnalytics = getInitializedAnalytics;
//# sourceMappingURL=analytics-service.js.map