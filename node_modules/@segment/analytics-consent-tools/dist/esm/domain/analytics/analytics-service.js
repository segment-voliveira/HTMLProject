import { createDeferred } from '@segment/analytics-generic-utils';
import { pipe } from '../../utils';
import { addBlockingMiddleware } from '../blocking-middleware';
import { createConsentStampingMiddleware } from '../consent-stamping';
import { getPrunedCategories } from '../pruned-categories';
import { validateAnalyticsInstance, validateCategories } from '../validation';
import { logger } from '../logger';
import { parseAllCategories } from '../config-helpers';
import { filterDeviceModeDestinationsForOptIn, segmentShouldBeDisabled, } from '../blocking-helpers';
/**
 * This class is a wrapper around the analytics.js library.
 */
export class AnalyticsService {
    get analytics() {
        return getInitializedAnalytics(this.uninitializedAnalytics);
    }
    get cdnSettings() {
        return this.cdnSettingsDeferred.promise;
    }
    async getAllCategories() {
        const allCategories = this.settings.integrationCategoryMappings
            ? parseAllCategories(this.settings.integrationCategoryMappings)
            : (await this.cdnSettings).consentSettings?.allCategories;
        return allCategories ?? [];
    }
    async getCategories() {
        const categories = await this.settings.getCategories();
        validateCategories(categories);
        return categories;
    }
    constructor(analytics, options) {
        this.cdnSettingsDeferred = createDeferred();
        /**
         * Allow for gracefully passing a custom disable function (without clobbering the default behavior)
         */
        this.createDisableOption = (categories, disable) => {
            if (disable === true) {
                return true;
            }
            return (cdnSettings) => {
                return (segmentShouldBeDisabled(categories, cdnSettings.consentSettings) ||
                    (typeof disable === 'function' ? disable(cdnSettings) : false));
            };
        };
        validateAnalyticsInstance(analytics);
        this.settings = options;
        this.uninitializedAnalytics = analytics;
        this.ogAnalyticsLoad = analytics.load.bind(analytics);
    }
    async loadWithFilteredDeviceModeDestinations(...[settings, options]) {
        const initialCategories = await this.getCategories();
        const _filterDeviceModeDestinationsForOptIn = (cdnSettings) => filterDeviceModeDestinationsForOptIn(cdnSettings, initialCategories, {
            shouldEnableIntegration: this.settings.shouldEnableIntegration,
            integrationCategoryMappings: this.settings.integrationCategoryMappings,
        });
        return this.load(settings, {
            ...options,
            updateCDNSettings: pipe(_filterDeviceModeDestinationsForOptIn, options?.updateCDNSettings ?? ((id) => id)),
            disable: this.createDisableOption(initialCategories, options?.disable),
        });
    }
    /**
     * The orignal analytics load function, but also stores the CDN settings on the instance.
     */
    load(...[settings, options]) {
        return this.ogAnalyticsLoad(settings, {
            ...options,
            updateCDNSettings: pipe(options?.updateCDNSettings || ((id) => id), (cdnSettings) => {
                logger.debug('CDN settings loaded', cdnSettings);
                // extract the CDN settings from this call and store it on the instance.
                this.cdnSettingsDeferred.resolve(cdnSettings);
                return cdnSettings;
            }),
        });
    }
    /**
     * Replace the load fn with a new one
     */
    replaceLoadMethod(loadFn) {
        this.analytics.load = loadFn;
    }
    page() {
        this.analytics.page();
    }
    configureBlockingMiddlewareForOptOut() {
        addBlockingMiddleware(this.cdnSettings, this.analytics, {
            integrationCategoryMappings: this.settings.integrationCategoryMappings,
            shouldEnableIntegration: this.settings.shouldEnableIntegration,
        });
    }
    configureConsentStampingMiddleware() {
        const { pruneUnmappedCategories } = this.settings;
        // normalize getCategories pruning is turned on or off
        const getCategoriesForConsentStamping = async () => {
            const categories = await this.getCategories();
            if (pruneUnmappedCategories) {
                return getPrunedCategories(categories, await this.getAllCategories());
            }
            return categories;
        };
        const MW = createConsentStampingMiddleware(getCategoriesForConsentStamping);
        this.analytics.addSourceMiddleware(MW);
    }
    /**
     * Dispatch an event that looks like:
     * ```ts
     * {
     * "type": "track",
     *  "event": "Segment Consent Preference Updated",
     *  "context": {
     *    "consent": {
     *      "categoryPreferences" : {
     *         "C0001": true,
     *         "C0002": false,
     *    }
     *  }
     * ...
     * ```
     */
    consentChange(categories) {
        logger.debug('Consent change', categories);
        try {
            validateCategories(categories);
        }
        catch (e) {
            // not sure if there's a better way to handle this
            return console.error(e);
        }
        const CONSENT_CHANGED_EVENT = 'Segment Consent Preference Updated';
        this.analytics.track(CONSENT_CHANGED_EVENT, undefined, {
            consent: { categoryPreferences: categories },
        });
    }
}
/**
 * Get possibly-initialized analytics.
 *
 * Reason:
 * There is a known bug for people who attempt to to wrap the library: the analytics reference does not get updated when the analytics.js library loads.
 * Thus, we need to proxy events to the global reference instead.
 *
 * There is a universal fix here: however, many users may not have updated it:
 * https://github.com/segmentio/snippet/commit/081faba8abab0b2c3ec840b685c4ff6d6cccf79c
 */
export const getInitializedAnalytics = (analytics) => {
    const isSnippetUser = Array.isArray(analytics);
    if (isSnippetUser) {
        const opts = analytics._loadOptions ?? {};
        const globalAnalytics = window[opts?.globalAnalyticsKey ?? 'analytics'];
        // we could probably skip this check and always return globalAnalytics, since they _should_ be set to the same thing at this point
        // however, it is safer to keep buffering.
        if (globalAnalytics?.initialized) {
            return globalAnalytics;
        }
    }
    return analytics;
};
//# sourceMappingURL=analytics-service.js.map