import { AnalyticsConsentError } from '../types/errors';
import { logger } from './logger';
import { ValidationError } from './validation/validation-error';
/**
 * Thrown when a load should be cancelled.
 */
export class AbortLoadError extends AnalyticsConsentError {
    constructor(loadSegmentNormally) {
        super('AbortLoadError', '');
        this.loadSegmentNormally = loadSegmentNormally;
    }
}
export class LoadToken {
    constructor(options) {
        this.options = options;
    }
}
export class LoadContext {
    constructor() {
        this.isAbortCalled = false;
        this.isLoadCalled = false;
        this.abortLoadOptions = {
            loadSegmentNormally: true,
        };
        this.loadOptions = {
            /**
             * Opt-in consent
             */
            consentModel: 'opt-in',
        };
    }
    /**
     * Allow analytics.js to be initialized with the consent wrapper.
     * Note: load just means 'allowed to load' -- we still wait for analytics.load to be explicitly called.
     */
    load(options) {
        this.isLoadCalled = true;
        this.loadOptions = { ...this.loadOptions, ...options };
        logger.debug('ctx.load called', this.loadOptions);
    }
    /**
     * Abort the _consent-wrapped_ analytics.js initialization
     */
    abort(options) {
        this.isAbortCalled = true;
        this.abortLoadOptions = { ...this.abortLoadOptions, ...options };
        logger.debug('Abort consent wrapper', this.loadOptions);
    }
    validate() {
        if (this.isAbortCalled && this.isLoadCalled) {
            throw new ValidationError('both abort and load should not be called');
        }
    }
}
/**
 * Wrapper for shouldLoadSegment fn
 */
export const normalizeShouldLoadSegment = (shouldLoadSegment) => {
    return async () => {
        const loadCtx = new LoadContext();
        await shouldLoadSegment?.(loadCtx);
        loadCtx.validate();
        return loadCtx;
    };
};
//# sourceMappingURL=load-context.js.map